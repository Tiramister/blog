---
title: "Educational Codeforces Round 79 E - New Year Permutations"
date: 2020-01-30
tags: [codeforces]
links:
  - label: "Problem link"
    url: "https://codeforces.com/contest/1279/problem/E"
  - label: "My Submission"
    url: "https://codeforces.com/contest/1279/submission/69809286"
---

## 問題

(原文はかなり長いので，ここでは言い換え後の同値な問題を述べる．)

長さ $n$ の順列 $(p\_i)$ が*良い順列*であるとは，総和が $n$ である正整数列 $(k\_j)$ が存在して，各 $j$ について以下が成り立つことである．

- $d\_j = \\sum\_\{j\'=1\}\^\{j-1\} k\_\{j\'\}$ とする．
- $q\_i = p\_\{i + d\_j\} - d\_j (1 \\leq i \\leq k\_j)$ として長さ $k\_j$ の数列 $(q\_j)$ を作る．
- この $(q\_j)$ が巡回順列になっていて，かつ $q\_1 = k\_j$ である．

より直感的には，前から長さ $k\_1, \\cdots, k\_l$ の「先頭が末尾を指す巡回順列」に分解できる，ということである．

長さ $n$ の良い順列で，辞書順 $k$ 番目のものを存在すれば出力せよ．

### 制約

- $1 \\leq n \\leq 50$
- $1 \\leq k \\leq 10\^\{18\}$

## 考察

上の言い換え自体もそこまで簡単ではないのだが，それを書いているとキリがないので省略した．

良い順列の前に「先頭が末尾を指す巡回順列」について考える．これを便宜上「_きれいな順列_」と呼ぶことにする．

まず長さ $n$ のきれいな順列の性質をグラフで表現すると，「1 つのサイクルからなり， $1$ から $n$ に辺が張られている有向グラフ」となる．
その個数を $l\_n$ とおくと，これは「 $1$ と $n$ が隣接する円順列の個数」なので $l\_n = (n - 2)!$ と分かる(ただし $l\_1 = 1$ )．

次に「長さ $n$ のきれいな順列で $k$ 番目のものは何か」という問題を考える．これは普通の順列同様，頂点 $2$ から $n - 1$ まで順に「どの頂点に辺を張るか」を考えていけばいい．ただしその行き先の頂点は入次数が $0$ で，かつ閉路を作ってはならない．

これを満たす「今辺を張れる頂点」を管理するには**UnionFind**の構造が使える．具体的には，有向辺 $uv$ が張られたときに $u$ を $v$ の親にする．すると

- 入次数が 0 $\\iff$ 根である.
- $v$ から $u$ に張ると閉路ができる $\\iff u$ は $v$ の親である．

となるので，根の集合から親を抜いたものが候補となる．

最後に良い順列について考える．長さ $n$ の良い順列の個数は，「前から長さいくつのきれいな順列を作るか」を考えると

$$
c\_n = \\sum\_\{k = 1\}\^\{n - 1\} l\_k c\_\{n - k\}
$$

で求まる．さらに長さ $m$ のきれいな順列を作ったときにできる良い順列は先頭が $m$ なので，良い順列は $m$ について辞書順となる．よってこれも貪欲で $k$ 番目を求めることができる．

## 実装例

当然オーバーフローするので， $\\infty$ で抑えるような和積の関数を作ってやるといい．特に積は注意で，掛けてから $\\min$ を取ると掛けている途中でオーバーフローすることがある．先に除算でオーバーするかどうか判定すればこれは防げる．

あとこの手の問題は $k$ が 0-indexed の方が自然に除算ができてやりやすい．それでも依然脳はバグるが．

{{<code file="0.cpp" language="cpp">}}
