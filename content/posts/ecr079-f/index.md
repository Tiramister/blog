---
title: "Educational Codeforces Round 79 F - New Year and Handle Change"
date: 2020-01-08
tags: [codeforces]
links:
  - label: Problem link
    url: https://codeforces.com/contest/1279/problem/F
  - label: My Submission
    url: https://codeforces.com/contest/1279/submission/68388249
---

## 問題

$0, 1$ からなる長さ $n$ の数列 $\\\{ a\_i \\\}$ が与えられる．この数列に対して，以下の操作を $k$ 回まで行う．

- $\\\{ a\_i \\\}$ から長さ $l$ の連続部分列を選ぶ．
- その部分列を全て $0$ か全て $1$ に変える．

$s = \\sum a\_i$ としたとき， $\\min(s, n - s)$ の最小値を求めよ．

### 制約

- $1 \\leq l \\leq n \\leq 10\^6$
- $1 \\leq k \\leq 10\^6$

## 考察

$s$ を小さくすることにしてしまえば，極力多くの要素を $0$ にする問題になる．これを数列の $0, 1$ を反転させて 2 回解けばいい．

まずシンプルな解法として， $dp\_\{i, j\} =$ 「 $a[0, i]$ について， $j$ 回操作を行ったときの $s$ の最小値」という DP が考えられる．選ぶ部分列は重複しないようにするのが最善なので， $\\\{ a\_i \\\}$ を $l$ だけ $0$ でかさ増しすればこれは $O(n\^2)$ で計算できる．

これの計算量を落とすために， **Alien DP** というテクニックを使う．
簡単に説明すると，

- 操作回数を覚える代わりに，操作を 1 回行う毎にペナルティ $p$ を加えることにする．
- 最適解の操作回数は $p$ が大きいほど小さくなる．
- そこで最適解の操作回数が $k$ 回になるようなペナルティを二分探索すればいい．

という感じ．ただし $k$ 回が最適であるような $p$ が存在すること(この性質は凸性と呼ばれる)が必要で，．今回の問題はこれが満たされているらしい[^1]．

[^1]: [証明らしきコメント](https://codeforces.com/blog/entry/72577?#comment-568669)

## 実装例

以下の実装では，

- ペナルティに対する操作回数は最小のものを求める．
- ペナルティの上界と下界，二分探索のループ回数はかなり適当．

としている．また，ペナルティ 0 で操作回数が $k$ 回以下の場合はそれがそのまま答えになることに注意．

{{<code file="0.cpp" language="cpp">}}
