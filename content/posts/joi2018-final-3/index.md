---
title: "JOI 2018 本選 C - 団子職人(Dango Maker)"
date: 2020-01-30
tags: [joi]
links:
  - label: "Problem link"
    url: "https://onlinejudge.u-aizu.ac.jp/challenges/sources/JOI/Final/0649?year=2018"
  - label: "My Submission"
    url: "https://onlinejudge.u-aizu.ac.jp/solutions/problem/0649/review/4141140/misteer/C++14"
---

## 問題

`RGW`の 3 文字からなる $n \\times m$ のグリッドがある．

ここから，以下を満たすブロックを重複がないように最大でいくつ取り出せるか求めよ．

- 左から順に`RGW`が並ぶ $1 \\times 3$ のブロック．
- 上から順に`RGW`が並ぶ $3 \\times 1$ のブロック．

### 制約

- $1 \\leq n, m \\leq 10\^3$

## 考察

「各列を何行前の`R`で消費したか」を保持することで $O(n3\^m)$ なら解ける(実装はしたくないが)．ここから計算量を落とすには，ブロック同士の依存関係をより深く見る必要がある．

以下の配置を見れば分かるように，`R`から縦に取る場合，左下 2 つの`R`から横に取ってはならない．逆にそうしていなければ，他の場所でどのような取り方をしていても必ず`R`から縦に取れる．

```
......
...R..
..RGW.
.RGW..
......
```

ここから， **依存関係は右上がりのライン上に横たわっている** ことが分かる．つまり，各ラインについて独立した問題に分けることができる．

各ラインについてブロック数を最大化するのは，2 つ前まで「どちらの方向に取ったか」を保持する DP でできる．縦に取るときは直前 2 回とも横に取っていてはならない．

## 実装例

「下に $m$ 行架空の行が存在する」と仮定すると実装しやすい．

あと結構 TL がきついので注意．実装によっては「縦，横，取らない」の 3 状態で持つと落ちるので，「縦」と「取らない」をまとめると良い．

{{<code file="0.cpp" language="cpp">}}

## 余談: 最大マッチング解法

グリッド $(i, j)$ に対して，そこを始点として「縦に取れる」なら $u\_\{i, j\}$ ，「横に取れる」なら $v\_\{i, j\}$ が頂点として存在するグラフを考える．このグラフに「互いに依存するもの同士」に辺を張ると，同じ方向のブロック同士は依存しないため，これは(特に最大次数が 3 以下の) **二部グラフ** をなす．

よって二部グラフの最大独立集合問題に帰着できて，これは最大マッチングで解くことができる．このグラフが上で述べたように斜めのライン毎に独立に作れることを考えると，計算量は $O(nm\\sqrt\{m\})$ になる．計算量だけで見るとかなり厳しいが，構築方法からしてヤバいグラフは作れないはずなので割と間に合うかもしれない．
