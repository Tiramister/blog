---
title: HACK TO THE FUTURE 2021 予選
date: 2020-11-08
tags: [atcoder, marathon]
links:
  - label: 問題
    url: https://atcoder.jp/contests/future-contest-2021-qual/tasks/future_contest_2021_qual_a
  - label: 提出
    url: https://atcoder.jp/contests/future-contest-2021-qual/submissions/17924564
---

## 問題

$20 \times 20$ のグリッド上に、 $0 \sim 99$ が書かれたカードが 1 枚ずつ置かれている。

この上をロボットが移動する。ロボットはカードスタックを 1 つ持っており、以下のいずれかを毎ターン行える。

- 上下左右に隣接するマスへ移動する。
- 今いるマスにカードが置かれている場合、そのカードを拾う。
- 今いるマスにカードが置かれていない場合、カードスタックの一番上のカードをそのマスに置く。

最初ロボットは左上隅のマスにいて、カードスタックは空である。
底から $0 \sim 99$ の順番でカードスタックにカードが並ぶようにするとき、ロボットの移動回数を最小化せよ。

## 考察

### 基本方針

最初に考えていた方針が以下の 3 つ。

1.  $0 \sim 99$ の順に回収する。
2.  全回収してからカードを $10 \times 10$ にまとめて置き、順番に回収し直す。
3.  全回収 → 並べ直し → 再回収を $10$ 枚ずつ行う。

1 は期待値 $2000$ くらいなので却下、3 も 10 枚が散り散りだと最悪で実装も面倒そうなので却下。
というわけで、以降 2 の方針で突き進むことになる。

後は 2 のまとめて置くときの置き方だが、これはシンプルに蛇腹折りで固定した。
これには実装が簡単なこと以外にもう 1 つ理由があるが、それは後ほど述べる。

### 山登り法

2 に対して山登り法を用いるのだが、近傍状態は **回収順序の 2 点 swap** とした。
なぜこの近傍を選んだかと言うと、差分が爆速で計算できるためである。
というのも、差分を計算するためには選ばれたカードの前後しか見なくてよい。
先程蛇腹折りを採用したのも、差分計算を簡単にするためである。

ループ内の実装は以下のような感じで、差分計算に 10 行しか要していない。

{{<code file="climb.cpp" language="cpp" title="山登り法">}}

この方針で山登り法を実装すると、158,098 点が得られた(平均 838 ムーブ、95 位相当)。

### 焼きなまし法

この山登り法を焼きなまし法に変更するのだが、あいにく焼きなまし法をちゃんと実装したことがない。
時間は十分あったので調べた結果、 [この記事](http://gasin.hatenadiary.jp/entry/2019/09/03/162613) の実装を丸パクリすることにした。かなり分かりやすく実装が説明されていて助かった(ありがとうございます)。

そして焼きなまし法を実装した結果、162,838 点に伸びた(平均 743 ムーブ、46 位相当)。焼きなまし法すげー。

### ちょっと改善

最後に、全部回収する必要はないことに気づく。つまり最後に並べ直す領域を $[10, 19] \times [10, 19]$ とすると、この領域に最初から入っているカードは拾わなくても良い。

この改善を施して、初期解や温度を色々とイジってみた結果、最終的に 164,514 点まで伸びた(平均 710 ムーブ、24 位)。

## 実装

{{<code file="main.cpp" language="cpp" title="最終解法">}}
