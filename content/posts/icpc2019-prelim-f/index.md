---
title: "ICPC 2019 国内予選 F - 色の切り替え"
date: 2020-09-03
tags: [icpc]
links:
  - label: "Problem link"
    url: "https://onlinejudge.u-aizu.ac.jp/challenges/sources/ICPC/Prelim/1637"
  - label: "My Submission"
    url: "https://onlinejudge.u-aizu.ac.jp/solutions/problem/1637/review/4814470/misteer/C++14"
---

## 問題

$n$ 頂点の無向完全重み付きグラフが与えられる。辺 $uv$ の重みは $w\_\{uv\}$ である。
また、各辺には赤か黒のいずれかの色がついている。

これからこのグラフに対して、以下の操作を好きなだけ行う。

- $v \\in V$ を選ぶ。
- $v$ と隣接する全ての辺について、その色を反転 (赤 ↔ 黒) させる。

赤い辺からなるグラフが全域木となるようにできるか判定し、できるなら赤い辺の重みの総和の最小値を求めよ。

### 制約

- $2 \\leq n \\leq 300$
- $1 \\leq w\_\{uv\} \\leq 10\^5$

## 考察

以降、辺 $uv$ が赤いときに限り「頂点 $u, v$ は隣接している」と言うことにする。

葉である頂点 $r$ を 1 つ固定する。すると、 $r$ と接続する 1 つの頂点 ($s$ とする) 以外は全て $r$ と隣接しない。つまり $r, s$ を固定すると、初期状態における辺 $vr$ の色によって、 $v$ を反転させるか否かが一意に定まる。

ここから「 $r, s$ を全探索して、得られたグラフが全域木をなすか判定する」という解法が出てくる。しかしナイーブに全域木判定をすると $O(n\^2)$ 掛かってしまうため、全体の計算量が $O(n\^4)$ となって厳しい。

### 高速化

なぜナイーブな全域木判定に $O(n\^2)$ かかるかというと、隣接する頂点を列挙するときに、他の頂点を全て見なければいけないためである。
もし隣接している頂点だけを列挙できれば、UnionFind にてサイクルが生じた時点で列挙を打ち切ることで、 $O(n)$ で判定ができる(全域木の辺は高々 $n - 1$ 本なため)。これを実現する。

まず $r$ を固定したら、全ての頂点が $r$ と隣接しないように他の頂点を反転させる。そしてこのグラフに対して隣接リストを構築する。

この後 $s$ を固定すると、 $s$ 周りの隣接関係だけが変化する。つまり $s$ が関与しなければ、先程作った隣接リストをそのまま使える。
よって $s$ に対して適当な場合分けをすることで、隣接頂点を無駄なく列挙できるようになる。

## 実装例

以下の実装では、全域木判定にて「 $s$ と接続する辺を最初に全部加える」ことで、それ以降 $s$ と接続する辺を無視できるようにしている。

{{<code file="0.cpp" language="cpp">}}
