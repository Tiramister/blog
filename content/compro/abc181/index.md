---
title: "AtCoder Beginner Contest 181"
date: 2020-11-02
tags: [atcoder, abc]
links:
  - label: "Contest link"
    url: "https://atcoder.jp/contests/abc181"
---

## 結果

※ Codeforces で遅刻したので、A 問題を 1 分と仮定して time を算出している。

|      |  A   |  B   |  C   |   D   |   E   |   F   |
| :--: | :--: | :--: | :--: | :---: | :---: | :---: |
| time | 1:00 | 2:13 | 5:39 | 12:51 | 22:35 | 42:56 |
|  Δ   | 1:00 | 1:13 | 3:26 | 7:12  | 9:44  | 20:21 |

## 問題

### C - Collinearity

3 点の組を全部試せばよい。判定は $dx\_1 \cdot dy\_2 = dy\_1 \cdot dx\_2$ でやれば、楽だし $dx=0$ の場合も対処できる。

### D - Hachi

$8$ の倍数の有名な判定方法として、「下 3 桁が $8$ の倍数か見る」というのがある( $1000$ が $8$ の倍数であるため)。
よって考えうる下 3 桁を全探索すればよく、これは各数字が何回出現したかを持っておけば可能。

厄介なのは $N \leq 2$ のケースで、この場合 leading zero を考慮する必要がある。
コンテスト中はこのケースも統一的に扱おうとして酷いことになった。例外処理する方が丸いと思う。

### E - Transformable Teacher

先生とマッチする相手を固定すると、残りは小さい方から 2 人ずつペアを組んでいくのが最善となる。
これは前と後ろから累積和を前計算すれば $O(1)$ で求まる。
先生の身長は、`lower_bound()`を使えば $O(\log M)$ で相手より大きい方と小さい方を両方試せる。

この問題のように両側から累積を取る問題は、実装で index が壊れやすい。
以下の実装では、コメントで対応する区間を明記している。

### F - Silver Woods

半径を二分探索することを考える。
半径 $r$ を固定したとき、円の中心が通れる場所は

- 釘から距離 $r$ 以上
- 壁(直線 $y = \pm 100$)から距離 $r$ 以上

である場所となる。したがって、

- 釘を中心とする半径 $r$ の円
- 直線 $y = \pm (100 - r)$

を横切らずに(接触は可)点を左から右へ動かせるか、という問題に言い換えられる。

点が横切れないのはどんなときかというと、上と下の壁を繋ぐ円の連鎖がある場合である。
よって各円と壁を頂点として、互いに交わる(接触はセーフ)なら辺が張られているようなグラフを考えると、上の壁から下の壁が連結ならアウトとなる。これは DSU で判定可能。

最初二分探索を整数でやって(距離の 2 乗は常に整数のため)バグらせたので、結局浮動小数点数を使うことにした。

## 反省

- 全体的に、実装に少し面倒な部分があるコンテストだった。F はかなり面白い。
- D のように「コーナーケースを統一的に扱おうとした結果、却ってバグが増える」ということはしばしばあって、判断が難しい。
  - 例外処理をするとバグが潜みうる場所が増えるので、それはそれでリスキー。
- E の「両側から累積を取る」という実装には苦手意識があるが、今回はスムーズに行ったように思う。
- F は考察がスムーズに行ってよかった。実装がやや詰まり気味だったのが反省点。
